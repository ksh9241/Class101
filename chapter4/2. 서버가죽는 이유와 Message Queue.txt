서버가 죽었다. = 
1. 일부 요청이 실패한다.
2. 모든 요청이 실패한다.
	- 지나치게 높은 트래픽으로 행이 걸렸을 때 모든 요청에 실패할 가능성이 높다.
	- 해결방법 : 자연스럽게 해소 및 애플리케이션 재시작

- CPU Bound Application : CPU 사용을 많이 필요로 하는 해쉬연산을 다량 요청했을 때 실패한다.
- DB Bound Application : DB를 사용하는 게시글 insert와 select를 다량 요청했을 때 실패한다.

- 요청이 많을 때 실패하는 이유
톰캣 기본 성능 ( Queue Size : 100, Thread : 200, TimeOut : 30초 ) [ 변경 가능 ]
톰캣에 사용자 요청이 들어옴 -> Queue에 요청 들어감 -> 큐에 먼저들어온 순서대로 놀고있는 스레드가 받아서 처리함. -> 스레드의 개수보다 큐에 들어오는 요청이 많을 경우 큐에서 요청대기 -> 응답시간이 길어지면서 큐사이즈보다 많은 요청이 들어오기 시작할 때부터 해당 요청은 실패하게 됨. -> 이 과정에서 큐에 들어와서 30초의 시간이상 대기하면 타임아웃 처리로 실패됨.

문제 1.
큐 사이즈를 늘리면 큐사이즈가 커져서 대기하는 요청이 많아지지만 타임아웃으로 인한 실패는 똑같음.

문제 2.
타임아웃 시간을 늘리면 오히려 실패되고 말아야 할 요청들이 계속 기다리면서 처리시간이 늘어남

문제 3.
스레드의 수를 늘리면 CPU를 공유하고 해쉬 연산은 CPU에 의해 이루어지기 때문에 스레드가 많아져도 똑같이 wating 시간이 길어짐.

해결방법
클라이언트에서 들어오는 많은 요청을 톰캣의 Queue에 담아서 순차적으로 처리하는 것이 아닌 MessageQueue를 사용하여 DB에 처리한다.

MQ의 장점
1. 비동기성 : DB속도와 무관하게 메시지를 누락없이 저장했다가 처리할 수 있게 된다.
2. Application 간 의존성 제거 : A App에서 B App로 데이터를 보낼 때 B App를 호출하여 데이터를 보낼 경우 A는 B에 의존성이 생기며, B App가 다운될 경우 데이터 유실이 발생됨. 
MQ를 사용하여 A -> MQ -> B로 데이터가 이동됨. B App가 중간에 잠시 다운되도 데이터 유실이 발생하지 않음.
3. 실패 시 재실행 가능 -> 신뢰성 : 재실행된다고해서 메시지가 유실되지않는 건 아님.
4. 확장성 : 하나의 큐에 여러개의 App가 동시에 데이터를 넣거나 뺄 수 있음.



요청이 쓰레드를 오래 사용할수록 쓰레드는 빠르게 고갈되고 큐 사이즈는 금방 가득 차버린다. 그렇게 되면 나머지 요청은 500에러나 타임아웃이 발생한다.
요청 늦게 응답 -> 빠른 쓰레드 고갈